<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-core-resize-sensor/at-core-resize-sensor.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-elements/at-dashboard-elements.html">
<link rel="import" href="at-core-dashboard-echo.html">
<link rel="import" href="../at-core-schema/at-core-schema.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">

<dom-module id="at-core-dashboard">
  <template>
    <style include="at-form-common"></style>
    <style>
      .at-core-dashboard-wrapper {
        position: relative;
        height: 100%;
      }

      :host(:focus) {
        outline: none;
      }

      [class*='col-'] {
        padding-left: 0;
        padding-right: 0;
        min-height: inherit;
      }

      at-form-text {
        padding-left: 15px;
        padding-right: 15px;
        min-height: 76px;
      }

      #insertPoint {
        position: relative;
      }

      at-form-checkbox {
        min-height: 76px;
      }
        /* workaround for IE11 flexbox min-height bug */

        _:-ms-fullscreen,
        at-form-checkbox::before {
          content: "";
          display: inline-block;
          min-height: 38px;
          visibility: hidden;
        }

      .vertical .col-6.at-form-checkbox {
        min-height: 32px;
        margin-bottom: 18px;
      }

      .vertical .col-6 at-form-checkbox {
        min-height: 32px;
      }
        /* workaround for IE11 flexbox min-height bug */

        _:-ms-fullscreen,
        .vertical .col-6 at-form-checkbox::before {
          content: "";
          display: inline-block;
          min-height: 16px;
          visibility: hidden;
        }
    </style>
    <div class="at-core-dashboard-wrapper">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clear-float"></div>
      <div id="insertPoint"></div>
    </div>
    <content></content>
  </template>
</dom-module>

<script>
  'use strict';
  Polymer({
    is: 'at-core-dashboard',
    behaviors: [Tangere.behavior.handleLink, Tangere.behaviors.i18n],
    hostAttributes: {
      tabindex: 0
    },
    properties: {
      /**
       * Specification of elements that should appear on the form.<br/>
       * Provide either an object or string.<br/>
       * List property definitions inside properties object.<br/>
       *
       * @property schema
       * @type Stirng or Object
       * @default { properties: {} }
       */
      schema: {
        type: Object,
        value: function () {
          var result = {
            properties: {}
          };
          return result;
        },
        observer: 'schemaChanged'
      },
      data: {
        type: Object,
        value: function () {
          return {};
        },
        observer: 'dataChanged'
      },
      /**
       * When true hides all elements.
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged'
      },
      /**
       * When true disables all elements.
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      valid: {
        type: Boolean,
        notify: true,
        value: true,
        readOnly: true
      },
      /**
       * at-core-dashboard can now have a one column or two column layout <br/>
       * by default a one column layout is used but a two column layout can be specified <br/>
       * layout = 'horizontal' renders the two column layout <br/>
       * layout = 'vertical' renders the single column layout <br/>
       *
       * @property layout
       * @type string
       * @default vertical
       */
      // added for #684
      layout: {
        type: String,
        value: "vertical",
        observer: 'layoutChanged',
        xtype: "enum",
        xvaluelist: "horizontal,vertical"
      }

    },
    get model() {
      return this.data.model;
    },
    set model(newValue) {
      this.data.model = newValue;
    },
    set valid(newValue) { },
    ready: function () {
      this.elementsToValidate = [];
      this._isReady = true;

      var self = this;
      this.addEventListener('focus', function (event) {
        if (event.currentTarget.is !== "at-core-dashboard") {
          return;
        }
        if (!event.target.is) {
          return;
        }
        var propertyDefinitions = self.schema.properties;
        var propertyNames = propertyDefinitions ? Object.keys(propertyDefinitions) : [];
        if (propertyDefinitions && propertyNames.length > 0) {
          // focus first element
          var propertyName = propertyNames[0];
          var element = self.getElement(propertyName);
          if (element.focus) {
            element.focus();
          }
        }
      });
    },

    attached: function () {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
      resizeSensor.addEventListener('resize-sensed', function (event) {
        var newWidth = event.detail.value.width;
        // console.log('at-core-dashboard new width: ' + newWidth + 'px');
        coreForm.updateLayout(newWidth);
      });
    },

    updateLayout: function (newWidth, oldWidth) {

      if (newWidth < 600) {
        this.layout = "vertical";
      } else {
        this.layout = "horizontal";
      }
    },

    hideChanged: function (newValue, oldValue) {
      var self = this;
      var insertPoint = this.$.insertPoint;

      if (this.schema && this.schema.properties) {
        var properties = this.schema.properties;
        var propNames = Object.keys(properties);
        propNames.forEach(function (propName, index) {
          var formElement = Polymer.dom(insertPoint).querySelector('#' + propName);
          if (formElement) {
            Polymer.dom(formElement.parentElement).classList.remove('hidden');
            formElement.hide = newValue;
          }
        });
      }
    },

    // when user switches to field settings tab, resize sensor is incorrectly initialized
    // so this function needs to be called to reinitialize the sensor
    resetResizeSensor: function () {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
    },

    schemaChanged: function (newValue, oldValue) {

      if (this._isReady) {
        var self = this;
        var schemaHelpers = window.schemaHelpers;
        if (schemaHelpers.isString(newValue)) {
          try {
            newValue = JSON.parse(newValue);
            this.schema = newValue;
            return;
          } catch (e) {
            console.log(e);
          }
        }

        if (schemaHelpers.isString(self.data)) {
          try {
            var dataObj = JSON.parse(self.data);
            self.data = dataObj;
          } catch (e) {
            console.log(e);
          }
        }


        self.elementsToValidate = [];

        var fieldsContainer = this.$.insertPoint;
        // clear the previous html content in the container
        Polymer.dom(fieldsContainer).innerHTML = '';

        var propertyDefinitions = newValue.properties;
        var propertyNames = [];
        var propertyDefinition;
        var defaultValue;
        var value;
        var xgridcols;
        var gridColsCssName;
        var fieldContainer;
        var formElement;
        var displayType;

        if (propertyDefinitions) {
          propertyNames = Object.keys(propertyDefinitions);

          // initialize data with defaults when empty
          if (Object.keys(self.data).length == 0) {
            self.data = this._calculateInitialDataFromSchemaProperties(propertyDefinitions);
          }

          // add schema elements to DOM
          propertyNames.forEach(function (propertyName) {

            if (schemaHelpers.isPropertyNameValid(propertyName)) {
              propertyDefinition = propertyDefinitions[propertyName];

              displayType = schemaHelpers.getDisplayType(propertyDefinition, []);

              // handle xgridcols
              xgridcols = displayType === "section" ? 12 : 6;
              if (schemaHelpers.notNullOrEmpty(propertyDefinition.xgridcols)) {
                xgridcols = parseInt(propertyDefinition.xgridcols);
              }

              // create element for field
              formElement = schemaHelpers.createElement(propertyName, displayType, propertyDefinition);
              Polymer.dom(formElement).setAttribute('id', propertyName);

              // create the field container
              fieldContainer = document.createElement('div');
              gridColsCssName = "col-" + xgridcols;
              Polymer.dom(fieldContainer).classList.add(gridColsCssName);

              // special container for at-form-toggle to allow smaller height in vertical mode
              if (formElement.tagName.toLowerCase() == "at-form-checkbox") {
                Polymer.dom(fieldContainer).classList.add("at-form-checkbox");
              }

              if (formElement.clearUIValidState !== undefined) {
                // at-form-section doesn't have clearUIValidState function nor does it need one
                formElement.clearUIValidState();
              }
              
              // setup changed listener for .value property to update data and call listeners
              if (formElement.value !== undefined) {
                formElement.addEventListener('value-changed', function (event) {                  
                  // get dom node of changed element
                  var changedElement = self.getElement(event.target.id);
                  self._updateDataObject(event.target.id, changedElement, event.detail.value);
                });
              }

              // setup changed listeners for stateProperties
              if (!!formElement.$meta && formElement.$meta[0].stateProperties !== undefined) {
                for (var i = 0; i < formElement.$meta[0].stateProperties.length; i++) {
                  var statePropertyName = formElement.$meta[0].stateProperties[i];

                  if (statePropertyName !== "value") {  // value is already handled in _updateDataObject

                    formElement.addEventListener(Polymer.CaseMap.camelToDashCase(statePropertyName) + '-changed', function (event) {
                      var elName = event.target.id;
                      var propName = event.type.replace("-changed", "");
                      propName = Polymer.CaseMap.dashToCamelCase(propName);
                      var ev = { name: elName + "." + propName, value: event.detail.value };
                      Polymer.signal("update-state-var", ev);
                    });

                  }
                }
              }

              if (formElement.valid !== undefined) {
                self.elementsToValidate.push(formElement);
              }

              // if at-core-dashboard is hidden, element should be hidden as well
              if (self.hide) {
                formElement.hide = true;
              }

              // append paper element to its container
              Polymer.dom(fieldContainer).appendChild(formElement);

              if (formElement.hide) {
                Polymer.dom(fieldContainer).classList.add('hidden');
              }

              // add container to as child to insertPoint
              Polymer.dom(fieldsContainer).appendChild(fieldContainer);

              // udpate the disabled status
              self.disabledChanged(self.disabled, self.disabled);
            } else {
              console.log('Property name is invalid. Skipping ' + propertyName + ' property');
              console.log('Property definition is:  ', schemaHelpers.formatJson(propertyDefinition));
            }
          });


          // initialize default values after elements are added to the DOM to ensure that listeners are already in place
          propertyNames.forEach(function (propertyName) {

            propertyDefinition = propertyDefinitions[propertyName];
            formElement = self.getElement(propertyName);

            if (!formElement) return;

            // handle default value
            defaultValue = propertyDefinition.default;


            // register .value variable in router and get value if exsting in state
            if (!!formElement.$meta && !(formElement.$meta[0].invisible === true) && formElement.$meta[0].stateProperties === undefined) {
              var ev = { name: propertyName, defaultValue: defaultValue, element: formElement };
              Polymer.signal("register-state-var", ev);
              if (ev.value !== undefined) defaultValue = ev.value;
            }

            // setup changed listeners for stateProperties
            if (!!formElement.$meta && formElement.$meta[0].stateProperties !== undefined) {
              for (var i = 0; i < formElement.$meta[0].stateProperties.length; i++) {
                var propName = formElement.$meta[0].stateProperties[i];                
                var elName = formElement.id;               
                var ev = { name: elName + "." + propName, defaultValue: formElement[propName], element: formElement };
                Polymer.signal("register-state-var", ev);
                if (ev.value !== undefined) formElement[propName] = ev.value;
              }
            }


            // if default value is not null or undefined and regular value is null or undefined
            // loading initial value will trigger value-changed event to update .data if defaultValue is valid
            if (schemaHelpers.notNullOrEmpty(defaultValue) && schemaHelpers.isNullOrEmpty(value)) {
              formElement.value = defaultValue;

              // *ma* setting the defautValue should be after setting up the event listener and only the listener should handle
              //      the value change; but it seems that setting the initial value doesn't trigger a change event consistently
              //      so as a workaround we call the event handler directly before setting up the listener

              self._updateDataObject(propertyName, formElement, defaultValue);
            }

          });

          self.fire('at-core-dashboard-rendered');
        } else {
          //TODO Implement clear of data property
        }

        // add div class="clearfix"
        var clearfixDiv = document.createElement('div');
        Polymer.dom(clearfixDiv).classList.add('clearfix');
        Polymer.dom(fieldsContainer).appendChild(clearfixDiv);

      }

      var resizeSensor = this.$.resizeSensor;
      resizeSensor.reset();
      var width = resizeSensor.queryWidth();
      this.updateLayout(width);

      this.addEventListener('keypress', function (event) {

        // validate() will trigger change event(s) if needed
        if (event.keyCode == 13) {
          this.validate();
        }

      });

      // send _start event
      var event = this._createEventObject("_start", null, null, null, this.data);
      this._invokeActionListeners(event);

    },

    /* *ij*
     Imperative data binding doesn't work in polymer 1.x.
     Using at-core-dashboard.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-dashboard.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementData function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console
     */
    updateFormElementData: function (elementId, value) {
      var fieldsContainer = this.$.insertPoint,
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + elementId);

      this.data[elementId] = value;
      if (schemaHelpers.valueNotReadOnly(fieldElement)) {
        fieldElement.value = value;
        // *ij* polymer js doesn't call valueChanged if value is of type array or object
        // we check for this situation and call valueChanged by hand
        if (schemaHelpers.isObject(fieldElement.value) || schemaHelpers.isArray(fieldElement.value)) {
          fieldElement.valueChanged(value, undefined);
        }
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    setElementState: function (elementId, state, value) {

      var element = Polymer.dom(this.$.insertPoint).querySelector('#' + elementId);
      if (element) {
        element[state] = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    getElement: function (elementId) {

      var insertPoint = this.$.insertPoint;
      var selector = '#' + elementId;
      var element = Polymer.dom(insertPoint).querySelector(selector);

      return element;
    },

    dataChanged: function (newValue, oldValue) {

      if (!this._isReady) {
        return;
      }

      return; // *ma*   can data be changed without changing an element first ??

      var fieldsContainer = Polymer.dom(this.$.insertPoint);
      var fieldElement;
      var properties = this.schema.properties;
      var initialData = this._calculateInitialDataFromSchemaProperties(properties);

      if (schemaHelpers.isString(newValue)) {
        try {
          newValue = JSON.parse(newValue);
          this.data = newValue;
          return;
        } catch (e) {
          console.log(e);
        }
      }

      if (schemaHelpers.isObject(oldValue)) {
        Object.keys(initialData).forEach(function (propertyName) {
          if (!newValue.hasOwnProperty(propertyName)) {
            newValue[propertyName] = initialData[propertyName];
          }
        });
      }

      var self = this;
      if (schemaHelpers.isObject(newValue)) {
        Object.keys(newValue).forEach(function (propertyName) {
          fieldElement = self.getElement(propertyName);
          if (schemaHelpers.valueNotReadOnly(fieldElement)) {
            fieldElement.value = newValue[propertyName];
          }
        });
      } else {
        console.log('at-core-dashboard expects objects as new value, but got ' + schemaHelpers.formatJson(newValue) + ' instead');
      }

      this.fire('data-changed', {
        value: this.data
      });
    },

    // invoke listeners on all elements listening for event
    _invokeActionListeners: function (event) {

      var properties = this.schema.properties;
      var propertyNames = Object.keys(properties);

      // check each element in the schema if it's listing for event.name
      for (var i = 0; i < propertyNames.length; i++) {
        var propName = propertyNames[i];
        var propDef = properties[propName];
        var element = this.getElement(propName); // element on which actionListener function will be called

        var actionListeners;

        if (propName == event.detail.srcName) {
          continue; // skip, element cannot listen to self
        }

        // ensure that actionListeners is an array
        if (typeof (propDef.actionListeners) == "string") {
          if (!propDef.actionListeners) {
            actionListeners = [propDef.actionListeners]; // convert single string to string array
          } else {
            actionListeners = []; // convert empty string into empty array
          }
        } else {
          actionListeners = propDef.actionListeners;
        }

        // ignore properties without listeners
        if (!propDef.actionListeners || actionListeners.length == 0) continue;

        for (var j = 0; j < actionListeners.length; j++) {

          var listenerName = actionListeners[j];

          if (typeof listenerName == "object" && !!listenerName.value) {
            // convert object { value: name} to "name"
            listenerName = listenerName.value;
          }
      
          // skip if element is not listening for current event
          // *todo* decide if eventtype for element name is  'name' (designer)   or  'name-changed'  (which seems more logical)
          if (listenerName != "_all" && listenerName != event.type && listenerName + "-changed" != event.type) {
            continue;
          }

          element.actionListener(event);

        }
      }
    },

    /*
     * This function is called on value-changed event for any element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateDataObject: function (property, changedElement, value) {

      // if an element has an .valid flag then the change is ignored when element value is not valid
      if (changedElement.valid !== undefined && !changedElement.valid) {
        return; // ignore change
      }

      this.data[property] = value;

      var event = this._createEventObject(property + "-changed", property, changedElement, value, this.data);

      this._invokeActionListeners(event);

      this.fire('data-changed', {
        property: property,
        value: this.data
      });

      if (!!changedElement.$meta && !(changedElement.$meta[0].invisible === true)) {
        var ev = { name: property, value: value };
        Polymer.signal("update-state-var", ev);
      }

    },

    _createEventObject: function (type, srcName, srcElement, value, data) {
      return {
        type: type,
        detail: {
          srcName: srcName,
          parameter: value,
          model: {
            state: data
          }
        }
      }
    },

    /* data is always valid
    _calculateFormValidState: function () {
      var isValid = true;

      this.elementsToValidate.forEach(function (element) {
        // there are elements that do not have valid property (like at-silver-transform or at-silver-datasource)
        // these elements are valid by default
        var elementValid = element.valid !== undefined ? element.valid : true;
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },
    */

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function () {
      var isValid = true;

      this.elementsToValidate.forEach(function (element) {
        var elementValid = element.validate();
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },

    disabledChanged: function (newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint;
      var fieldElement;
      var properties = this.schema.properties;

      Object.keys(properties).forEach(function (propertyName) {
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
          if (newValue) {
            fieldElement.disabled = newValue;
          } else {
            fieldElement.disabled = Boolean(properties[propertyName].disabled);
          }
        }
      });
    },

    layoutChanged: function (newValue, oldValue) {
      this.toggleClass('vertical', newValue === 'vertical', this.$.insertPoint);
    },

    _convertPropertiesToSchemaValues: function (properties) {
      var result = {
        schema: {
          properties: {}
        },
        values: {}
      },
        property,
        propDef,
        innerProp,
        propObj;

      for (property in properties) {
        propObj = result.properties[property] = {};
        propDef = properties[property];
        for (innerProp in propDef) {
          if (innerProp === 'value') {
            result.values[property] = propDef[innerProp];
          } else {
            propObj[innerProp] = propDef[innerProp];
          }
        }
      }

      return result;
    },

    /**
     * this function creates initial data object from schema properties
     */
    _calculateInitialDataFromSchemaProperties: function (properties) {

      var result = {};
      var propertyNames = Object.keys(properties);
      var propSchemaDef;
      var calculatedValue;

      propertyNames.forEach(function (propName, index) {
        propSchemaDef = properties[propName];

        // if .default exists in propSchemaDef that is the calculatedValue
        if (propSchemaDef.default !== undefined) {
          calculatedValue = propSchemaDef.default;
          result[propName] = calculatedValue;
        }
      });

      return result;
    }

  });

  function isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  }

  function isFunction(obj) {
    return Object.prototype.toString.apply(obj) === "[object Function]";
  }
</script>