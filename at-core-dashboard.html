<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-core-schema/at-core-schema.html">
<link rel="import" href="../at-core-resize-sensor/at-core-resize-sensor.html">
<link rel="import" href="../at-carbon-tabs/at-carbon-tab.html">
<link rel="import" href="../at-carbon-tabs/at-carbon-tabs.html">
<link rel="import" href="at-core-dashboard-echo.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-now/now-card-styles.html">
<link rel="import" href="../at-core-style-classes/at-core-style-classes.html">
<link rel="import" href="../at-core-signals/at-core-signals.html">
<link rel="import" href="../tangere/at-actionhandler-behavior.html">
<link rel="import" href="../at-core-modal/at-core-modal.html">
<link rel="import" href="../at-core-api-post/at-core-api-post.html">
<link rel="import" href="../at-core-modal-element/at-core-modal-element.html">

<dom-module id="at-core-dashboard">
  <template>
    <style include="at-form-common"></style>
    <style include="at-core-style-classes"></style>
    <style include="now-card-styles"></style>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }

      :host * {
        box-sizing: border-box;
      }

      .revealed.revealed.revealed.revealed.revealed.revealed.revealed {
        background-color: white !important;
        box-shadow: rgba(0, 0, 0, 0.098) 0px 2px 4px, rgba(0, 0, 0, 0.1) 0px 0px 3px !important;
        border: #E8EBF1 !important;
      }

      .at-core-dashboard-wrapper {
        position: relative;
        height: 100%;
      }

      :host(:focus) {
        outline: none;
      }

      [class*='col-'] {
        padding: 0;
        float: left;
        min-height: inherit;
      }

      at-form-text {
        padding-left: 15px;
        padding-right: 15px;
        min-height: 76px;
      }

      #insertPoint {
        position: relative;
      }

      at-form-checkbox {
        min-height: 76px;
      }

      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 38px;
        visibility: hidden;
      }

      .vertical .col-6.at-form-checkbox {
        min-height: 32px;
        margin-bottom: 18px;
      }

      .vertical .col-6 at-form-checkbox {
        min-height: 32px;
      }

      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      .vertical .col-6 at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 16px;
        visibility: hidden;
      }

      .vertical at-carbon-tabs {
        margin-bottom: 18px;
      }

      /* TEMPORARY SOLUTION. REMOVE WHEN A BETTER SOLUTION IS AVAILABLE */
      /* 
        at-actionhandler-behavior and at-taphandler-behavior define styles as global css rules
        styles from at-actionhandler-behavior and at-taphandler-behavior are inlined here, because at-core-dashboard's shadowRoot acts as boundary for css rules
        there is a specific use case on /App#!at-now/start-now?mode=workplace where these classes are used to control what is visible on a card when card uses at-core-view to render its content dynamically
       */
      :host(.collapsed) .expanded-only {
        display: none !important;
      }

      :host(.expanded) .collapsed-only {
        display: none !important;
      }

      :host(.desktop) .mobile-only {
        display: none !important;
      }

      :host(.mobile) .desktop-only {
        display: none !important;
      }
      /* END OF TEMPORARY SOLUTION. REMOVE WHEN A BETTER SOLUTION IS AVAILABLE */

    </style>
    <div class="at-core-dashboard-wrapper wrapper card" id="wrapper">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clear-float"></div>
      <div id="insertPoint"></div>
    </div>
    <content></content>
    <at-core-api-post id="post" on-api-response="_apiResponse"></at-core-api-post>
    <at-core-modal id="dialog"></at-core-modal>
    <at-core-modal-element id="modal" on-value-changed="_modalValueChanged"></at-core-modal-element>
  </template>
</dom-module>

<script>
  'use strict';
  Polymer({
    is: 'at-core-dashboard',
    behaviors: [Tangere.behavior.handleLink, Tangere.behaviors.i18n, Tangere.behaviors.actionhandler],
    hostAttributes: {
      tabindex: 0
    },
    properties: {
      /**
       * Specification of elements that should appear on the form.<br/>
       * Provide either an object or string.<br/>
       * List property definitions inside properties object.<br/>
       *
       * @property schema
       * @type Stirng or Object
       * @default { properties: {} }
       */
      schema: {
        type: Object,
        value: function() {
          var result = {
            properties: {}
          };
          return result;
        }
      },
      data: {
        type: Object,
        value: function() {
          return { _session: Tangere.session };
        },
        observer: 'dataChanged'
      },
      /**
       * When true hides all elements.
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged'
      },
      /**
       * When true disables all elements.
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      /**
       * true when the mouse is over the element
       * @property hover
       * @type Boolean
       * @default false
       */
      hover: {
        type: Boolean,
        value: false
      },
      childActive: {
        type: Boolean,
        value: false
      },
      valid: {
        type: Boolean,
        notify: true,
        value: true,
        readOnly: true
      },
      namePrefix: {
        type: String,
        notify: true,
        value: ""
      },
      renderMode: {
        type: String,
        notify: true,
        value: ""
      },
      service: {
        type: String,
        value: "",
        notify: true
      },
      /**
       * at-core-dashboard can now have a one column or two column layout <br/>
       * by default a one column layout is used but a two column layout can be specified <br/>
       * layout = 'horizontal' renders the two column layout <br/>
       * layout = 'vertical' renders the single column layout <br/>
       *
       * @property layout
       * @type string
       * @default vertical
       */
      layout: {
        type: String,
        value: "vertical",
        observer: 'layoutChanged',
        xtype: "enum",
        xvaluelist: "horizontal,vertical"
      },

      /**
      * at-core-form sectionMode governs the rendering of at-form-section <br/>
      * sectionMode === default, renders at-form-section as a heading
      * sectionMode === tab, renders at-form-section as a tab
      * all form-section elements form a tab group
      * iron-pages hold the elements belonging to a tab group
      * clicking a tab changes elements currently visible on screen
      *
      * @property sectionMode
      * @type string
      * @default default
      */
      sectionMode: {
        type: String,
        value: 'auto',
        xtype: "enum",
        xvaluelist: [{
          title: "Always Sections",
          value: "sections"
        }, {
          title: "Always Tabs",
          value: "tabs"
        }, {
          title: "Responsive",
          value: "auto"
        }, {
          title: "Tabs in mobile mode",
          value: "mobile"
        }]
      },

      /**
       * holds the value of the currently active tab when sectionMode === tab <br/>
       * has value of "" when sectionMode === default
       *
       * @property activeTab
       * @type string
       * @default ""
       */
      activeTab: {
        type: String,
        value: "",
        observer: '_activeTabChanged'
      }
    },


    get model() {
      return this.data.model;
    },

    set model(newValue) {
      this.data.model = newValue;
      this.$.post.url = newValue._card ? newValue._card.ServiceUrl : "";
      this.dataChanged(this.data);
    },

    set valid(newValue) { },

    observers: [
      '_schemaChanged(schema, activeTab)',
      '_sectionLayoutChanged(sectionMode, layout)',
      '_stateChanged(hover, childActive)'
    ],

    listeners: {
      'resolve-name-prefix': 'resolveNamePrefix',
      'mouseenter': '_onHostHover',
      'focus': '_onHostHover',   // win touch, focus implies hover
      'mouseleave': '_onHostUnhover',
      'card-active': '_onCardActiveState',
      'notify': '_onNotify'
    },

    _onNotify: function(e) {

      var event = this._createEventObject(e.detail.event, null, null, null, this.data);
      this._invokeActionListeners(event);

      e.preventDefault();
      e.stopPropagation();
      return false;
    },

    _onCardActiveState: function(e) {
      this.childActive = e.detail.value;

      // *todo* we need a customizable solution, this currently only handles cisco UC and theme
      this.$.wrapper.classList.toggle("revealed", this.childActive);

    },

    _onHostHover: function(e) {
      this.hover = true;
    },

    _onHostUnhover: function(e) {
      this.hover = false;
    },

    resolveNamePrefix: function(e) {
      // allow nested elements (e.g. at-link) to retrieve the namePrefix of the "next" container
      e.detail.namePrefix = this.namePrefix;
      e.preventDefault();
    },

    ready: function() {
      this._isReady = true;
    },

    attached: function() {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
      resizeSensor.addEventListener('resize-sensed', function(event) {
        var newWidth = event.detail.value.width;
        // console.log('at-core-dashboard new width: ' + newWidth + 'px');
        coreForm.updateLayout(newWidth);
      });
    },

    updateLayout: function(newWidth, oldWidth) {
      if (isNaN(newWidth)) { return; }
      if (newWidth < 600) {
        this.layout = "vertical";
      } else {
        this.layout = "horizontal";
      }
    },

    /**
     * Focuses the element on the form with given elementId
     * If elementId is provided and element with provided elementId exists, its focused.
     * If elementId is not provided first element on the form is focused
     */
    setFocus: function(elementId) {
      var _sh = window.schemaHelpers;
      if (!_sh.isObject(this.schema) || !_sh.isObject(this.schema.properties)) {
        return;
      }

      var element;
      if (_sh.isString(elementId) && elementId !== "") {
        element = this.getElement(elementId);
      } else {
        // focus first element on the form
        var propertyNames = Object.getOwnPropertyNames(this.schema.properties);
        var firstElementName = propertyNames[0];
        element = this.getElement(firstElementName);
      }

      if (element !== null && _sh.isFunction(element.focus)) {
        element.focus();
      }
    },
    _stateChanged: function(hover, childActive) {
      var newValue = hover || childActive;

      if (this._state == undefined) this._state = newValue;
      if (this._state == newValue) return;
      this._state = newValue;

      if (!this.__revealAble || this.__revealAble.length == 0 || Tangere.session.browser.mobile) return;
      for (var i = 0; i < this.__revealAble.length; i++) {
        this.__revealAble[i].revealed = newValue;
      }
    },

    _revealed: function() {
      if (Tangere.session.browser.mobile) return true; // in mobile elements are always revealed
      return this.hover || this.childActive; // reveal elements when mouse is over host
    },

    hideChanged: function(newValue, oldValue) {
      var self = this;
      var insertPoint = this.$.insertPoint;

      if (this.schema && this.schema.properties) {
        var properties = this.schema.properties;
        var propNames = Object.getOwnPropertyNames(properties);
        propNames.forEach(function(propName, index) {
          var formElement = Polymer.dom(insertPoint).querySelector('#' + propName);          
          // if at-core-dashboard didn't complete rendering formElement will be null
          // its safe to return here, because during schema rendering .hide is set correctly by inspecting the value of at-core-dashboard.hide property
          // so each form element will be hidden correctly regardless of which happens / completes first - rendering or hideChanged
          if (formElement == null) return;
          if(formElement.hide != undefined) formElement.hide = newValue;
        });
      }
    },

    // when user switches to field settings tab, resize sensor is incorrectly initialized
    // so this function needs to be called to reinitialize the sensor
    resetResizeSensor: function() {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
    },

    _isObject: function(obj) {
      return Object.prototype.toString.apply(obj) === "[object Object]";
    },

    _isFunction: function(obj) {
      return Object.prototype.toString.apply(obj) === "[object Function]";
    },

    refresh: function() {
      if (!this._isObject(this.schema) || !this._isObject(this.schema.properties)) return;
      var propertyNames = Object.getOwnPropertyNames(this.schema.properties);

      propertyNames.forEach(function(propName) {
        var elt = this.getElement(propName);
        if (elt && this._isFunction(elt.refresh)) {
          elt.refresh();
        }
      }.bind(this));
    },

    // map legacy xtypes
    // this list is also in at-form-complex and at-core-dashboard
    // DO NOT EXTEND THIS LIST; for new elements xtype should be the element name, so there is no need to new elements to be in this list
    _displayTypeToFormElementMapping: {
      array: "at-form-array",
      boolean: "at-form-checkbox",
      toggle: "at-form-checkbox",
      code: "at-form-codemirror",
      json: "at-form-codemirror",
      object: "at-form-complex",
      date: "at-form-date",
      time: "at-form-date",
      datetime: "at-form-date",
      daterange: "at-form-daterange",
      file: "at-form-file",
      html: "at-form-html",
      image: "at-form-image",
      'enum': "at-form-lookup",
      lookup: "at-form-lookup",
      marked: "at-form-markdown",
      password: "at-form-password",
      number: "at-form-number",
      radio: "at-form-radio",
      section: "at-form-section",
      state: "at-form-state",
      string: "at-form-text",
      textarea: "at-form-textarea",
      cron: "at-form-cron",
      random: "at-form-random"
    },

    _getElementNameFromDisplayType: function(displayType) {
      var elementName = this._displayTypeToFormElementMapping[displayType];
      return elementName;
    },

    _schemaChanged: function(newValue) {
      var schemaHelpers = window.schemaHelpers;
      var self = this;

      // don't render empty initial schema
      if (!this._initialViewRendered && newValue && newValue.properties && Object.keys(newValue.properties).length == 0) {
        return;
      }

      if (schemaHelpers.isString(newValue)) {
        /*
        if newValue for schema is given as json string, parse it and assign it to this.schema
        if newValue is a valid json string this.schema will trigger __schemaChanged again so we return to prevent schema changes being applied twice
        if newValue is an invalid json string just return. Whatever the previous schema was that remains visible to the user
        */
        try {
          newValue = JSON.parse(newValue);
          this.schema = newValue;
        } catch (e) {
          console.log(e);
        }
        return;
      }

      if (!schemaHelpers.isObject(newValue) || !schemaHelpers.isObject(newValue.properties)) {
        return;
      }

      // figure out the list of the elements that should be imported
      var _properties = newValue.properties;
      var _propertyNames = Object.getOwnPropertyNames(newValue.properties);
      var nonImportedElements = [];

      var nonGroupedElements;
      var formGroups = [];
      var currentGroupName = "";
      var currentGroupElements = nonGroupedElements = [];

      _propertyNames.forEach(function(propName, index) {
        var propDef = _properties[propName];
        var displayType = schemaHelpers.getDisplayType(propDef, []);
        var elementName = self._getElementNameFromDisplayType(displayType);
        if (elementName == undefined) elementName = displayType;

        // propDef.default !== window is added to hanlde cases from polymer behaviors
        // where initial value for properities is window
        if (propDef.default !== window) {
          // element is not loaded; schedule it for importHref
          var scheduledPropDef = JSON.parse(JSON.stringify(propDef));
          scheduledPropDef.elementName = elementName;
          nonImportedElements.push(scheduledPropDef);
        }

        if (displayType !== 'section') {
          currentGroupElements.push({ name: propName, definition: propDef });
        } else {
          // open a new group
          currentGroupName = propName;
          currentGroupElements = [{ name: propName, definition: propDef }];
          formGroups.push({
            name: currentGroupName,
            label: propDef.title || currentGroupName,
            elements: currentGroupElements
          });
        }
      });

      this._nonGroupedElements = nonGroupedElements;
      this._formGroups = formGroups;

      if (nonImportedElements.length) {
        var pendingImportsCount = nonImportedElements.length;

        nonImportedElements.forEach(function(propDef, index) {
          // To construct elemHref we need static information about what (type, xtype) maps to which at-form element
          // Right now, only $meta in each element contains this information and central array of components is populated with $meta information
          // So, to dynamically importHref needed elements we need to introduce static information (which will just be a copy paste from $meta of each element)
          var elementName = propDef.elementName;

          // construct elemHref
          var compUrl = this.resolveUrl("../");

          if (document.URL.indexOf("/elements/designer-element/") >= 0) {
            compUrl = "/components/";
          }

          if (window.ComponentsBase != undefined) {
            compUrl = window.ComponentsBase;
          }
          var elemHref = compUrl + elementName + "/" + elementName + ".html";

          // special handling for dashboard-echo because its in the same folder where at-core-dashboard is
          if (elementName == "at-core-dashboard-echo") {
            elemHref = compUrl + "at-core-dashboard/" + elementName + ".html";
          }

          self.importHref(elemHref, function(e) {
            // import was successful
            pendingImportsCount -= 1;
            if (!pendingImportsCount) {
              self._render();
            }
          }, function(e) {
            // import failed
            console.log("import failed: " + e.target.href);
          }, true);
        }, this);
      } else {
        this._render();
      }
    },

    _render: function() {

      this.toggleClass("desktop", Tangere.session.browser.desktop, this.$.wrapper);
      this.toggleClass("mobile", Tangere.session.browser.mobile, this.$.wrapper);

      var self = this;
      var schemaHelpers = window.schemaHelpers;
      var divPrototype = document.createElement('div');
      var nonGroupedElements = this._nonGroupedElements;
      var formGroups = this._formGroups;

      self.elementsToValidate = [];

      var fieldsContainer = this.$.insertPoint;
      // clear the previous html content in the container
      Polymer.dom(fieldsContainer).innerHTML = '';

      // process schema.$meta.xclass and schema.$meta.xstyle
      if (schemaHelpers.isObject(this.schema.$meta)) {
        if (schemaHelpers.isString(this.schema.$meta.xclass) && this.schema.$meta.xclass !== "") {
          var cssClasses = this.schema.$meta.xclass.split(' ');
          cssClasses.forEach(function(cssClass, index) {
            Polymer.dom(fieldsContainer).classList.add(cssClass);
          });
        }
        if (schemaHelpers.isString(this.schema.$meta.xstyle) && this.schema.$meta.xstyle !== "") {
          Polymer.dom(fieldsContainer).setAttribute('style', this.schema.$meta.xstyle);
        }
      }

      // initialize data with defaults when empty
      if (!self.data || Object.getOwnPropertyNames(self.data).length === 0) {
        var initialData = this._calculateInitialDataFromSchemaProperties(self.schema.properties);
        if (!schemaHelpers.areEqual(self.data, initialData)) {
          self.data = initialData;
        }
      }

      // add schema elements to DOM
      nonGroupedElements.forEach(function(element) {
        var propertyName = element.name;
        var propertyDefinition = element.definition;
        self._renderSingleElement(propertyName, propertyDefinition, divPrototype, fieldsContainer);
      });

      if (formGroups.length) {
        var sectionMode = self.sectionMode;
        var layout = self.layout;
        self._hideTabs = sectionMode === "sections" ||
          (sectionMode === "auto" && layout === "horizontal") ||
          (sectionMode === "mobile" && layout === "horizontal");

        self._hideHeadings = ["mobile", "tabs"].indexOf(sectionMode) !== -1 ||
          (sectionMode === "auto" && layout === "vertical");
        var selectedSection = self.activeTab || formGroups[0].name;

        // create tab group
        var col12 = divPrototype.cloneNode(true);
        Polymer.dom(col12).classList.add('col-12');
        var carbonTabs = document.createElement('at-carbon-tabs');
        Polymer.dom(fieldsContainer).appendChild(col12);
        Polymer.dom(col12).appendChild(carbonTabs);
        carbonTabs.hidden = self._hideTabs;

        formGroups.forEach(function(group, index) {
          var name = group.name;
          var label = group.label;
          var carbonTab = document.createElement('at-carbon-tab');
          Polymer.dom(carbonTab).setAttribute('id', name);
          Polymer.dom(carbonTab).innerHTML = label;
          Polymer.dom(carbonTabs).appendChild(carbonTab);

          var ironPage = divPrototype.cloneNode(true);
          Polymer.dom(fieldsContainer).appendChild(ironPage);
          Polymer.dom(ironPage).setAttribute('at-core-form-section-id', name);
          self.toggleClass('hidden', !self._hideTabs && name !== selectedSection, ironPage);

          var elements = group.elements;
          elements.forEach(function(element, index) {
            var propertyName = element.name;
            var propertyDefinition = JSON.parse(JSON.stringify(element.definition));
            if (!index) {
              propertyDefinition.hide = self._hideHeadings;
            }

            self._renderSingleElement(propertyName, propertyDefinition, divPrototype, ironPage);
          });
        });

        carbonTabs.$.tabsContent.attrForSelected = 'id';
        carbonTabs.selected = selectedSection;
        self.activeTab = selectedSection;

        carbonTabs.addEventListener('selected-changed', function(event) {
          if (self._hideTabs) { return; }
          self.activeTab = event.detail.value;
          var sections = Polymer.dom(self.$.insertPoint).querySelectorAll('div[at-core-form-section-id]');
          sections.forEach(function(section, index) {
            var sectionId = section.getAttribute('at-core-form-section-id');
            self.toggleClass('hidden', sectionId !== self.activeTab, section);
          });
        });
      }

      var propertyNames = Object.getOwnPropertyNames(self.schema.properties);
      var propertyDefinitions = self.schema.properties;

      // initialize default values after elements are added to the DOM to ensure that listeners are already in place
      propertyNames.forEach(function(propertyName) {

        var propertyDefinition = propertyDefinitions[propertyName];
        var formElement = self.getElement(propertyName);

        if (!formElement) return;

        // handle default value
        var defaultValue = propertyDefinition.default;
        var value;  // *todo* is value still needed? seems that no value is ever assigned

        // register .value variable in router and get value if exsting in state
        if (!!formElement.$meta && !(formElement.$meta[0].invisible === true) && formElement.$meta[0].stateProperties === undefined) {
          var ev = { name: propertyName, defaultValue: defaultValue, element: formElement };
          Polymer.signal("register-state-var", ev);
          if (ev.value !== undefined) defaultValue = ev.value;
        }

        // setup changed listeners for stateProperties
        if (!!formElement.$meta && formElement.$meta[0].stateProperties !== undefined) {
          for (var i = 0; i < formElement.$meta[0].stateProperties.length; i++) {
            var propName = formElement.$meta[0].stateProperties[i];
            var elName = formElement.id;

            // service is a special property where container could provide a fallback property value
            if (propName == "service" && this.service && !formElement[propName]) {
              formElement[propName] = this.service;
            }

            var ev = { name: elName + "." + propName, defaultValue: formElement[propName], element: formElement };
            Polymer.signal("register-state-var", ev);
            if (ev.value !== undefined) formElement[propName] = ev.value;

          }
        }

        // if default value is not null or undefined and regular value is null or undefined
        // loading initial value will trigger value-changed event to update .data if defaultValue is valid
        if (schemaHelpers.notNullOrEmpty(defaultValue) && schemaHelpers.isNullOrEmpty(value)) {
          formElement.value = defaultValue;

          // *ma* setting the defautValue should be after setting up the event listener and only the listener should handle
          //      the value change; but it seems that setting the initial value doesn't trigger a change event consistently
          //      so as a workaround we call the event handler directly before setting up the listener

          self._updateDataObject(propertyName, formElement, defaultValue);
        }

      }, this);

      // add div class="clearfix"
      var clearfixDiv = document.createElement('div');
      Polymer.dom(clearfixDiv).classList.add('clear-float');
      Polymer.dom(fieldsContainer).appendChild(clearfixDiv);

      self.fire('rendered', this, { bubbles: false });

      //console.log("fire content-changed");
      self.fire('content-changed', this, { bubbles: true });

      var resizeSensor = this.$.resizeSensor;
      resizeSensor.reset();
      var width = resizeSensor.queryWidth();
      this.updateLayout(width);

      this.addEventListener('keypress', function(event) {

        // validate() will trigger change event(s) if needed
        if (event.keyCode == 13) {
          this.validate();
        }

      });

      // send _start event
      this._executeAction("initialize");
      var event = this._createEventObject("_start", null, null, null, this.data);
      this._invokeActionListeners(event);

      this._initialViewRendered = true;

    },

    _renderSingleElement: function(propertyName, propertyDefinition, divPrototype, fieldsFragment) {
      var self = this;
      var defaultValue;
      var value;
      var xgridcols;
      var gridColsCssName;
      var fieldContainer;
      var formElement;
      var displayType;

      if (schemaHelpers.isPropertyNameValid(propertyName)) {
        displayType = schemaHelpers.getDisplayType(propertyDefinition, []);

        // handle xgridcols
        xgridcols = displayType === "section" ? 12 : 6;
        if (schemaHelpers.notNullOrEmpty(propertyDefinition.xgridcols)) {
          xgridcols = parseInt(propertyDefinition.xgridcols);
        }
        xgridcols = displayType === "section" ? 12 : xgridcols;

        // special handling for at-core-view modelRoot
        if (displayType == "at-core-view") {
          if (!propertyDefinition.modelRoot) propertyDefinition.modelRoot = "state.model"; // default is state.model
          if (propertyDefinition.modelRoot == ".") propertyDefinition.modelRoot = "";           // . == empty modelRoot
        }
        
        var elementName = self._getElementNameFromDisplayType(displayType);
        if (elementName == undefined) elementName = displayType;

        // create element for field
        formElement = schemaHelpers.createElement(propertyName, displayType, propertyDefinition, elementName);
        Polymer.dom(formElement).setAttribute('id', propertyName);

        // copy .schema to new element if it provide a .schema property
        if (typeof formElement.schema != "undefined") {
          formElement.schema = this.schema;
        }

        // maintain list of element which contain revealable elements
        if (!this.__revealAble) this.__revealAble = [];
        if (typeof formElement.revealed == "boolean") {
          formElement.revealed = this._revealed();
          this.__revealAble.push(formElement);
        }

        // create the field container
        fieldContainer = document.createElement('div');
        gridColsCssName = "col-" + xgridcols;

        // handle xclass setting
        if (schemaHelpers.notNullOrEmpty(propertyDefinition.xclass)) {
          var xclasses = propertyDefinition.xclass.split(" ");
          for (var ic = 0; ic < xclasses.length; ic++) {
            Polymer.dom(fieldContainer).classList.add(xclasses[ic]);
          }
        }

        Polymer.dom(fieldContainer).classList.add(gridColsCssName);

        // handle xstyle setting
        if (schemaHelpers.notNullOrEmpty(propertyDefinition.xstyle)) {
          Polymer.dom(fieldContainer).setAttribute('style', propertyDefinition.xstyle);
        }


        // special container for at-form-toggle to allow smaller height in vertical mode
        if (formElement.tagName.toLowerCase() == "at-form-checkbox") {
          Polymer.dom(fieldContainer).classList.add("at-form-checkbox");
        }

        if (formElement.clearUIValidState !== undefined) {
          // at-form-section doesn't have clearUIValidState function nor does it need one
          formElement.clearUIValidState();
        }

        // setup changed listener for .value property to update data and call listeners
        if (formElement.properties["value"] != undefined) {
          formElement.addEventListener('value-changed', function(event) {
            // get dom node of changed element
            var changedElement = self.getElement(event.target.id);
            self._updateDataObject(event.target.id, changedElement, event.detail.value);
          });
        }

        // setup changed listeners for stateProperties
        if (!!formElement.$meta && formElement.$meta[0].stateProperties !== undefined) {
          for (var i = 0; i < formElement.$meta[0].stateProperties.length; i++) {
            var statePropertyName = formElement.$meta[0].stateProperties[i];

            if (statePropertyName !== "value") {  // value is already handled in _updateDataObject

              formElement.addEventListener(Polymer.CaseMap.camelToDashCase(statePropertyName) + '-changed', function(event) {
                var elName = event.target.id;
                var propName = event.type.replace("-changed", "");
                propName = Polymer.CaseMap.dashToCamelCase(propName);
                var ev = { name: elName + "." + propName, value: event.detail.value };
                Polymer.signal("update-state-var", ev);
              });

            }
          }
        }

        if (formElement.valid !== undefined) {
          self.elementsToValidate.push(formElement);
        }

        // if at-core-dashboard is hidden, element should be hidden as well
        if (self.hide && formElement.hide != undefined) {
          formElement.hide = true;
        }

        // append paper element to its container
        Polymer.dom(fieldContainer).appendChild(formElement);

        // add container to as child to insertPoint
        Polymer.dom(fieldsFragment).appendChild(fieldContainer);

        // udpate the disabled status
        self.disabledChanged(self.disabled, self.disabled);
      } else {
        console.log('Property name is invalid. Skipping ' + propertyName + ' property');
        console.log('Property definition is:  ', schemaHelpers.formatJson(propertyDefinition));
      }
    },

    _sectionLayoutChanged: function(sectionMode, layout) {
      var carbonTabs = Polymer.dom(this.$.insertPoint).querySelector('at-carbon-tabs');
      var sections = Polymer.dom(this.$.insertPoint).querySelectorAll('div[at-core-form-section-id]');
      var headings = Polymer.dom(this.$.insertPoint).querySelectorAll('at-form-section');
      var self = this;
      var sectionMode = self.sectionMode;
      var layout = self.layout;
      var hideTabs = self._hideTabs = sectionMode === "sections" ||
        (sectionMode === "auto" && layout === "horizontal") ||
        (sectionMode === "mobile" && layout === "horizontal");
      var hideHeadings = self._hideHeadings = ["mobile", "tabs"].indexOf(sectionMode) !== -1 ||
        (sectionMode === "auto" && layout === "vertical");

      var selectedSection = this.activeTab;
      if (carbonTabs) { carbonTabs.hidden = hideTabs; }
      sections.forEach(function(section, index) {
        var sectionId = section.getAttribute('at-core-form-section-id');
        self.toggleClass('hidden', !hideTabs && sectionId !== selectedSection, section);
      });

      headings.forEach(function(heading, index) {
        heading.hide = hideHeadings;
        self.toggleClass('hidden', hideHeadings, heading.parentElement);
      });

    },

    _activeTabChanged: function(newValue, oldValue) {
      // this is here to prevent rerendering of at-core-form when activeTab
      // is updated by clicking an at-carbon-tab on at-carbon-tabs

      var carbonTabs = Polymer.dom(this.root).querySelector('at-carbon-tabs');
      if (carbonTabs && carbonTabs.selected !== newValue) {
        carbonTabs.selected = newValue;
      }
    },

    /* *ij*
     Imperative data binding doesn't work in polymer 1.x.
     Using at-core-dashboard.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-dashboard.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementData function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console
     */
    updateFormElementData: function(elementId, value) {
      var fieldsContainer = this.$.insertPoint,
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + elementId);

      this.data[elementId] = value;
      if (schemaHelpers.valueNotReadOnly(fieldElement)) {
        fieldElement.value = value;
        // *ij* polymer js doesn't call valueChanged if value is of type array or object
        // we check for this situation and call valueChanged by hand
        if (schemaHelpers.isObject(fieldElement.value) || schemaHelpers.isArray(fieldElement.value)) {
          fieldElement.valueChanged(value, undefined);
        }
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    setElementState: function(elementId, state, value) {

      var element = Polymer.dom(this.$.insertPoint).querySelector('#' + elementId);
      if (element) {
        element[state] = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    getElement: function(elementId) {

      var insertPoint = this.$.insertPoint;
      var selector = '#' + elementId;
      var element = Polymer.dom(insertPoint).querySelector(selector);

      return element;
    },

    dataChanged: function(newValue, oldValue) {

      if (!this._isReady) {
        return;
      }

      if (!this._initialViewRendered) {
        return;  // view not yet rendered, so data is not really changed
      }

      // render again with new data
      this._render();

    },

    // invoke listeners on all elements listening for event
    _invokeActionListeners: function(event) {

      var properties = this.schema.properties;
      var propertyNames = Object.getOwnPropertyNames(properties);

      // check each element in the schema if it's listing for event.name
      for (var i = 0; i < propertyNames.length; i++) {
        var propName = propertyNames[i];
        var propDef = properties[propName];
        var element = this.getElement(propName); // element on which actionListener function will be called

        var actionListeners = [];
    
        if (propName == event.detail.srcName) {
          continue; // skip, element cannot listen to self
        }

        // ensure that actionListeners is an array
        if (typeof (propDef.actionListeners) == "string") {
          if (!propDef.actionListeners) {
            actionListeners = [propDef.actionListeners]; // convert single string to string array
          } else {
            actionListeners = []; // convert empty string into empty array
          }
        } else {
          actionListeners = propDef.actionListeners || [];
        }
                
        // fix issue that empty listener [] might be saved as [ "" ]
        if (actionListeners.length == 1 && actionListeners[0] === "") {
          actionListeners = [];
        }
        
        // if no listeners are specified then listen for _all per default
        if (actionListeners.length == 0) {
          actionListeners.push("_all");
        }

        for (var j = 0; j < actionListeners.length; j++) {

          var listenerName = actionListeners[j];

          if (typeof listenerName == "object" && !!listenerName.value) {
            // convert object { value: name} to "name"
            listenerName = listenerName.value;
          }

          // skip if element is not listening for current event
          // *todo* decide if eventtype for element name is  'name' (designer)   or  'name-changed'  (which seems more logical)
          if (listenerName != "_all" && listenerName != event.type && listenerName + "-changed" != event.type) {
            continue;
          }

          if (isFunction(element.actionListener)) {
            element.actionListener(event);
          }

        }
      }
    },

    /*
     * This function is called on value-changed event for any element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateDataObject: function(property, changedElement, value) {

      // if an element has an .valid flag then the change is ignored when element value is not valid
      if (changedElement.valid !== undefined && !changedElement.valid) {
        return; // ignore change
      }

      // special case - change in footer value changes renderMode as well
      if (changedElement.tagName == "AT-CARBON-CARD-FOOTER") {
        this.renderMode = value ? "expanded" : "collapsed";        
      }

      this.data[property] = value;

      var event = this._createEventObject(property + "-changed", property, changedElement, value, this.data);

      this._invokeActionListeners(event);

      this.fire('data-changed', {
        property: property,
        value: this.data
      });

      if (!!changedElement.$meta && !(changedElement.$meta[0].invisible === true)) {
        var ev = { name: property, value: value };
        Polymer.signal("update-state-var", ev);
      }

    },

    _createEventObject: function(type, srcName, srcElement, value, data) {
      return {
        type: type,
        container: this,
        detail: {
          srcName: srcName,
          parameter: value,
          model: {
            state: data
          }
        }
      }
    },

    /* data is always valid
    _calculateFormValidState: function () {
      var isValid = true;

      this.elementsToValidate.forEach(function (element) {
        // there are elements that do not have valid property (like at-silver-transform or at-silver-datasource)
        // these elements are valid by default
        var elementValid = element.valid !== undefined ? element.valid : true;
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },
    */

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function() {
      var isValid = true;

      this.elementsToValidate.forEach(function(element) {
        var elementValid = element.validate();
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },

    disabledChanged: function(newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint;
      var fieldElement;
      var properties = this.schema.properties;

      Object.getOwnPropertyNames(properties).forEach(function(propertyName) {
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
          if (newValue) {
            fieldElement.disabled = newValue;
          } else {
            fieldElement.disabled = Boolean(properties[propertyName].disabled);
          }
        }
      });
    },

    layoutChanged: function(newValue, oldValue) {
      this.toggleClass('vertical', newValue === 'vertical', this.$.insertPoint);
    },

    _convertPropertiesToSchemaValues: function(properties) {
      var result = {
        schema: {
          properties: {}
        },
        values: {}
      },
        property,
        propDef,
        innerProp,
        propObj;

      for (property in properties) {
        propObj = result.properties[property] = {};
        propDef = properties[property];
        for (innerProp in propDef) {
          if (innerProp === 'value') {
            result.values[property] = propDef[innerProp];
          } else {
            propObj[innerProp] = propDef[innerProp];
          }
        }
      }

      return result;
    },

    /**
     * this function creates initial data object from schema properties
     */
    _calculateInitialDataFromSchemaProperties: function(properties) {

      var result = {};
      var propertyNames = Object.getOwnPropertyNames(properties);
      var propSchemaDef;
      var calculatedValue;

      propertyNames.forEach(function(propName, index) {
        propSchemaDef = properties[propName];

        // if .default exists in propSchemaDef that is the calculatedValue
        if (propSchemaDef.default !== undefined) {
          calculatedValue = propSchemaDef.default;
          result[propName] = calculatedValue;
        }
      });

      return result;
    }

  });

  function isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  }

  function isFunction(obj) {
    return Object.prototype.toString.apply(obj) === "[object Function]";
  }
</script>
