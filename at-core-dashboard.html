<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-core-resize-sensor/at-core-resize-sensor.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-form-text/at-form-text.html">
<link rel="import" href="../at-form-date/at-form-date.html">
<link rel="import" href="../at-form-daterange/at-form-daterange.html">
<link rel="import" href="../at-chart-core/at-chart-core.html">
<link rel="import" href="../at-chart-strudel/at-chart-strudel.html">
<link rel="import" href="../at-silver-transform/at-silver-transform.html">
<link rel="import" href="at-core-dashboard-echo.html">
<link rel="import" href="../at-core-schema/at-core-schema.html">

<dom-module id="at-core-dashboard">
  <template>
    <style include="at-form-common"></style>
    <style>
      .at-core-dashboard-wrapper {
        position: relative;
        height: 100%;
      }

      :host(:focus) {
        outline: none;
      }

      #insertPoint {
        position: relative;
      }

      at-form-checkbox {
        min-height: 76px;
      }
      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 38px;
        visibility: hidden;
      }

      .vertical .col-6.at-form-checkbox {
        min-height: 32px;
        margin-bottom: 18px;
      }

      .vertical .col-6 at-form-checkbox {
        min-height: 32px;
      }
      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      .vertical .col-6 at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 16px;
        visibility: hidden;
      }
    </style>
    <div class="at-core-dashboard-wrapper">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clear-float"></div>
      <div id="insertPoint"></div>
    </div>
    <content></content>
  </template>
</dom-module>

<script>
  'use strict';
  Polymer({
    is: 'at-core-dashboard',
    hostAttributes: {
      tabindex: 0
    },
    properties: {
      /**
       * Specification of elements that should appear on the form.<br/>
       * Provide either an object or string.<br/>
       * List property definitions inside properties object.<br/>
       *
       * @property schema
       * @type Stirng or Object
       * @default { properties: {} }
       */
      schema: {
        type: Object,
        value: function() {
          var result = {
            properties: {}
          };
          return result;
        },
        observer: 'schemaChanged'
      },
      data: {
        type: Object,
        value: function() {
          return {};
        },
        observer: 'dataChanged'
      },
      /**
       * When true hides all elements.
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged'
      },
      /**
       * When true disables all elements.
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      valid: {
        type: Boolean,
        notify: true,
        value: true,
        readOnly: true
      },
      /**
       * at-core-dashboard can now have a one column or two column layout <br/>
       * by default a one column layout is used but a two column layout can be specified <br/>
       * layout = 'horizontal' renders the two column layout <br/>
       * layout = 'vertical' renders the single column layout <br/>
       *
       * @property layout
       * @type string
       * @default vertical
       */
      // added for #684
      layout: {
        type: String,
        value: "vertical",
        observer: 'layoutChanged',
        xtype: "enum",
        xvaluelist: "horizontal,vertical"
      }

    },
    set valid(newValue) {},
    ready: function() {
      this.elementsToValidate = [];
      this._isReady = true;

      var self = this;
      this.addEventListener('focus', function(event) {
        if (event.currentTarget.is !== "at-core-dashboard") {
          return;
        }
        if (!event.target.is) {
          return;
        }
        var propertyDefinitions = self.schema.properties;
        var propertyNames = propertyDefinitions ? Object.keys(propertyDefinitions) : [];
        if (propertyDefinitions && propertyNames.length > 0) {
          // focus frist element
          var propertyName = propertyNames[0];
          var element = self.getElement(propertyName);
          if (element.focus) {
            element.focus();
          }
        }
      });
    },
    attached: function() {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
      resizeSensor.addEventListener('resize-sensed', function(event) {
        var newWidth = event.detail.value.width;
        // console.log('at-core-dashboard new width: ' + newWidth + 'px');
        coreForm.updateLayout(newWidth);
      });
    },
    updateLayout: function(newWidth, oldWidth) {
      // 377 is from fibonacci sequence; it should do just fine
      if (newWidth < 600) {
        this.layout = "vertical";
      } else {
        this.layout = "horizontal";
      }
    },
    hideChanged: function(newValue, oldValue) {
      var self = this;
      var insertPoint = this.$.insertPoint;

      if (this.schema && this.schema.properties) {
        var properties = this.schema.properties;
        var propNames = Object.keys(properties);
        propNames.forEach(function(propName, index) {
          var formElement = Polymer.dom(insertPoint).querySelector('#' + propName);
          if (formElement) {
            Polymer.dom(formElement.parentElement).classList.remove('hidden');
            formElement.hide = newValue;
          }
        });
      }
    },
    // ------------------------------
    // *ij* maybe one day when we have HTML7 and resize event for elements this function will not be necessary
    // this function is here to solve the problem in at-form-designer
    // when user switches to field settings tab, resize sensor is incorrectly initialized
    // so this function needs to be called to reinitialize the sensor
    resetResizeSensor: function() {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
    },
    // ------------------------------
    schemaChanged: function(newValue, oldValue) {
      if (this._isReady) {
        var self = this;
        var schemaHelpers = window.schemaHelpers;
        if (schemaHelpers.isString(newValue)) {
          try {
            newValue = JSON.parse(newValue);
            this.schema = newValue;
            return;
          } catch (e) {
            console.log(e);
          }
        }

        if (schemaHelpers.isString(self.data)) {
          try {
            var dataObj = JSON.parse(self.data);
            self.data = dataObj;
          } catch (e) {
            console.log(e);
          }
        }

        self.elementsToValidate = [];

        var fieldsContainer = this.$.insertPoint;
        // clear the previous html content in the container
        Polymer.dom(fieldsContainer).innerHTML = '';

        var propertyDefinitions = newValue.properties;
        var propertyNames = [];
        var propertyDefinition;
        var defaultValue;
        var value;
        var xgridcols;
        var gridColsCssName;
        var fieldContainer;
        var formElement;
        var displayType;

        if (propertyDefinitions) {
          propertyNames = Object.keys(propertyDefinitions);
          propertyNames.forEach(function(propertyName) {
            if (schemaHelpers.isPropertyNameValid(propertyName)) {
              propertyDefinition = propertyDefinitions[propertyName];

              // handle default value
              defaultValue = propertyDefinition.default;
              value = self.data[propertyName];
              // if default value is not null or undefined and regular value is null or undefined
              if (schemaHelpers.notNullOrEmpty(defaultValue) && schemaHelpers.isNullOrEmpty(value)) {
                // make the default value regular value
                self.data[propertyName] = defaultValue;
              }

              displayType = schemaHelpers.getDisplayType(propertyDefinition, []);

              // handle xgridcols
              xgridcols = displayType === "section" ? 12 : 6;
              if (schemaHelpers.notNullOrEmpty(propertyDefinition.xgridcols)) {
                xgridcols = parseInt(propertyDefinition.xgridcols);
              }

              // create element for field
              formElement = schemaHelpers.createElement(propertyName, displayType, propertyDefinition);

              // create the field container
              fieldContainer = document.createElement('div');
              gridColsCssName = "col-" + xgridcols;
              Polymer.dom(fieldContainer).classList.add(gridColsCssName);

              // special container for at-form-toggle to allow smaller height in vertical mode
              if (formElement.tagName.toLowerCase() == "at-form-checkbox") {
                Polymer.dom(fieldContainer).classList.add("at-form-checkbox");
              }

              if (schemaHelpers.isNullOrEmpty(self.data[propertyName])) {
                // at-core-dashboard.data doesn't contain an entry for the current property
                // add initial value of the formElement to the at-core-dashboard.data
                self.data[propertyName] = formElement.value;
              } else {
                // else set initial value from at-core-dashboard.data to fromElement
                formElement.value = self.data[propertyName];
              }
              if (formElement.clearUIValidState !== undefined) {
                // at-form-section doesn't have clearUIValidState function nor does it need one
                formElement.clearUIValidState();
              }

              formElement.addEventListener('value-changed', function(event) {
                if (!self._isBatchUpdate) {
                  self._updateDataObject(event.target.id, event.detail.value);
                }
              });

              Polymer.dom(formElement).setAttribute('id', propertyName);
              if (formElement.valid !== undefined) {
                self.elementsToValidate.push(formElement);
              }

              // if at-core-dashboard is hidden, element should be hidden as well
              if (self.hide) {
                formElement.hide = true;
              }

              // append paper element to its container
              Polymer.dom(fieldContainer).appendChild(formElement);

              if (formElement.hide) {
                Polymer.dom(fieldContainer).classList.add('hidden');
              }

              // add container to as child to insertPoint
              Polymer.dom(fieldsContainer).appendChild(fieldContainer);

              // udpate the disabled status
              self.disabledChanged(self.disabled, self.disabled);
            } else {
              console.log('Property name is invalid. Skipping ' + propertyName + ' property');
              console.log('Property definition is:  ', schemaHelpers.formatJson(propertyDefinition));
            }
          });
          self.fire('at-core-dashboard-rendered');
        } else {
          //TODO Implement clear of data property
        }

        // add div class="clearfix"
        var clearfixDiv = document.createElement('div');
        Polymer.dom(clearfixDiv).classList.add('clearfix');
        Polymer.dom(fieldsContainer).appendChild(clearfixDiv);

        // if any element is required in schema its valid state is updated after creation
        // at-core-dashboard needs to reflect that state
        if (self.elementsToValidate.length > 0) {
          self._calculateFormValidState();
        }
      }

      var resizeSensor = this.$.resizeSensor;
      resizeSensor.reset();
      var width = resizeSensor.queryWidth();
      this.updateLayout(width);

      /**
       * In scenarios where .data is set first and .schema set second, elements with action listeners need to be updated
       * since elements have valid values. The same holds true, when elements have default values set in .schema.properties.<property-name>.default
       */
      this._updateElementsThatHaveActionListeners();
    },
    /* *ij*
     OK. Imperative data binding doesn't work in polymer anymore.
     It may happen in the future but not in near future.
     Using at-core-dashboard.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-dashboard.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementData function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console

     Alternative to this approach is to create a completely new object each time you want to update the .data property
     IMO, this approach is a waste of time. An updateFormElementData function is much more efficient

     Another alternative to this approach is to have a function that will return the element itself. Than the client can do whatever he likes with the element
     not just update value. This approach seems reasonable for setFieldState action in at-form-rule-edit
     */
    updateFormElementData: function(elementId, value) {
      var fieldsContainer = this.$.insertPoint,
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + elementId);

      this.data[elementId] = value;
      if (schemaHelpers.valueNotReadOnly(fieldElement)) {
        fieldElement.value = value;
        // *ij* polymer js doesn't call valueChanged if value is of type array or object
        // we check for this situation and call valueChanged by hand
        if (schemaHelpers.isObject(fieldElement.value) || schemaHelpers.isArray(fieldElement.value)) {
          fieldElement.valueChanged(value, undefined);
        }
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    setElementState: function(elementId, state, value) {
      var element = Polymer.dom(this.$.insertPoint).querySelector('#' + elementId);
      if (element) {
        element[state] = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    getElement: function(elementId) {
      var insertPoint = this.$.insertPoint;
      var selector = '#' + elementId;
      var element = Polymer.dom(insertPoint).querySelector(selector);

      return element;
    },

    dataChanged: function(newValue, oldValue) {
      if (!this._isReady) {
        return;
      }

      var fieldsContainer = Polymer.dom(this.$.insertPoint);
      var fieldElement;
      var properties = this.schema.properties;
      var initialData = this._calculateInitialDataFromSchemaProperties(properties);

      if (schemaHelpers.isString(newValue)) {
        try {
          newValue = JSON.parse(newValue);
          this.data = newValue;
          return;
        } catch (e) {
          console.log(e);
        }
      }

      this._isBatchUpdate = true;

      if (schemaHelpers.isObject(oldValue)) {
        Object.keys(initialData).forEach(function(propertyName) {
          if (!newValue.hasOwnProperty(propertyName)) {
            newValue[propertyName] = initialData[propertyName];
          }
        });
      }
      var self = this;
      if (schemaHelpers.isObject(newValue)) {
        Object.keys(newValue).forEach(function(propertyName) {
          fieldElement = self.getElement(propertyName);
          if (schemaHelpers.valueNotReadOnly(fieldElement)) {
            fieldElement.value = newValue[propertyName];
          }
        });
      } else {
        console.log('at-core-dashboard expects objects as new value, but got ' + schemaHelpers.formatJson(newValue) + ' instead');
      }

      /**
       * When .data is set elements with action listeners need to be updated since they have valid values
       */
      this._calculateFormValidState();
      if (this.valid) {
        this._updateElementsThatHaveActionListeners();
      }

      this._isBatchUpdate = false;
      this.fire('data-changed', {
        value: this.data
      });
    },

    _updateElementsThatHaveActionListeners: function(propertyName) {
      var self = this;

      function isObject(obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
      }

      var properties = self.schema.properties;
      var propertyNames = Object.keys(properties);

      // iterate over property names in .schema.properties
      for (var i = 0; i < propertyNames.length; i++) {
        var propName = propertyNames[i];
        var propDef = properties[propName];

        // for each property create the event data object that will be passed into actionListener function
        var eventData;

        /**
        * When _updateElementsThatHaveActionListeners is called from schema-changed and data-changed propertyName will be undefined
        * When _updateElementsThatHaveActionListeners is called from _updateDataObject propertyName will be name of the element that caused the update
        */
        if (propertyName === undefined) {
          // when dashboard is initialized a event.type and event.parameter will be different for each property
          eventData = this._createEventDataObject(propName, this.data[propName], this.data);
        } else {
          // when dashboard is updated a event.type and event.parameter will be the same for all properties
          eventData = this._createEventDataObject(propertyName, this.data[propertyName], this.data);
        }

        // action listeners array is part of .schema.properties.<property-name> structure; actionListeners is an array of strings
        // where each string is a name of an element on the dashboard
        if (isArray(propDef.actionListeners)) {
          for (var j = 0; j < propDef.actionListeners.length; j++) {
            var listenerElement; // this holds the reference to the element whose name is in the actionListeners array
            var defaultValue; // default value is value from at-core-dashboard.schema.properties.<element-name>.default
            var initialValue; // initialValue is initial value of the listener element, as in listenerElement.properties.value.value
            var element = self.getElement(propName); // element holds the reference to the element on which actionListener function will be called
            var listener = propDef.actionListeners[j];
            // actionListeners is either array of objects (comes from at-dashboard-designer) or array of strings; we need the listenerName as string
            var listenerName = isObject(listener) ? listener.value : listener;

            // element should not contain self in its actionListeners array; if that is the case, just skip the rest of the iteration
            if (listenerName === propName) {
              continue;
            }

            listenerElement = self.getElement(listenerName);
            defaultValue = self.schema.properties[listenerName].default;
            initialValue = listenerElement.properties.value.value;

            // actionListener should not be called when .schema.properties.listenerElement is set without defaultValue
            // then listenerElement.valid is true and listenerElement.value === initialValue

            // actionListener should be called when .schema.properties.listenerElement is set with defaultValue
            // and listenerElement.valid is true; then listenerElement.value === defaultValue

            // actionListener should be called when user changes listenerElement and listenerElement.valid is true
            var listenerValueValid = listenerElement.valid !== undefined ? listenerElement.valid : true;
            if (listenerValueValid && listenerElement.value !== initialValue) {

              // at-silver-transform fires value-changed event but in data-changed _isBatchUpdate is true
              // so that event is suppressed; this suppression can be worked around by updating the at-core-dashboard.data
              // object after actionListener function finishes executing
              element.actionListener(eventData);

              // at-core-dashboard-echo doesn't have value property
              if (element.value !== undefined) {
                this.data[propName] = element.value;
              }
            }
          }
        }
      }
    },

    /*
     * This function is called on value-changed event for each element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateDataObject: function(property, value) {
      function isObject(obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
      }

      // holds the reference to the element whose value changed
      var changedElement = this.getElement(property);
      // changedElement can be at-silver-transform which doesn't have valid property
      if (changedElement.valid !== undefined && !changedElement.valid) {
        // if element is not valid just return
        return;
      }

      this.data[property] = value;
      this._calculateFormValidState();

      this._updateElementsThatHaveActionListeners(property);

      this.fire('data-changed', {
        property: property,
        value: this.data
      });
    },

    _createEventDataObject: function (name, value, data) {
      return {
        type: name + "-changed",
        detail: {
          parameter: value,
          model: {
            state: data
          }
        }
      }
    },

    _calculateFormValidState: function() {
      var isValid = true;

      this.elementsToValidate.forEach(function(element) {
        // there are elements that do not have valid property (like at-silver-transform or at-silver-datasource)
        // these elements are valid by default
        var elementValid = element.valid !== undefined ? element.valid : true;
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function() {
      var isValid = true;

      this.elementsToValidate.forEach(function(element) {
        var elementValid = element.validate();
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },

    disabledChanged: function(newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint;
      var fieldElement;
      var properties = this.schema.properties;

      Object.keys(properties).forEach(function(propertyName) {
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
          if (newValue) {
            fieldElement.disabled = newValue;
          } else {
            fieldElement.disabled = Boolean(properties[propertyName].disabled);
          }
        }
      });
    },
    layoutChanged: function(newValue, oldValue) {
      this.toggleClass('vertical', newValue === 'vertical', this.$.insertPoint);
    },
    _convertPropertiesToSchemaValues: function(properties) {
      var result = {
          schema: {
            properties: {}
          },
          values: {}
        },
        property,
        propDef,
        innerProp,
        propObj;

      for (property in properties) {
        propObj = result.properties[property] = {};
        propDef = properties[property];
        for (innerProp in propDef) {
          if (innerProp === 'value') {
            result.values[property] = propDef[innerProp];
          } else {
            propObj[innerProp] = propDef[innerProp];
          }
        }
      }

      return result;
    },
    /**
     * This function is created for task #773 at-core-dashboard .data handling
     * this function creates initial data object from schema properties
     * value for each entry is either default value from element or default value from schema (specified with default: '<value>')
     * dataChanged function calls this function
     */
    _calculateInitialDataFromSchemaProperties: function(properties) {
      var insertPoint = this.$.insertPoint;
      var result = {};
      var propertyNames = Object.keys(properties);
      var propSchemaDef;
      var calculatedValue;

      propertyNames.forEach(function(propName, index) {
        propSchemaDef = properties[propName];

        // if .default exists in propSchemaDef that is the calculatedValue
        if (propSchemaDef.default !== undefined) {
          calculatedValue = propSchemaDef.default;
        } else {
          // form is already created; query the self.$.insertPoint and get default value from element.properties.value.value
          var element = Polymer.dom(insertPoint).querySelector('#' + propName);
          if (element.properties.value !== undefined && element.properties.value.value !== undefined) {
            // at-form-section doesn't have value property nor does it need one
            calculatedValue = element.properties.value.value;
          }
        }

        result[propName] = calculatedValue;
      });

      return result;
    }

  });

  function isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  }

  function isFunction(obj) {
    return Object.prototype.toString.apply(obj) === "[object Function]";
  }
</script>
