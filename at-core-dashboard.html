<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-core-schema/at-core-schema.html">
<link rel="import" href="../at-core-resize-sensor/at-core-resize-sensor.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-carbon-tabs/at-carbon-tab.html">
<link rel="import" href="../at-carbon-tabs/at-carbon-tabs.html">
<link rel="import" href="at-core-dashboard-echo.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-now/now-card-styles.html">
<link rel="import" href="../at-core-style-classes/at-core-style-classes.html">
<link rel="import" href="../at-core-signals/at-core-signals.html">

<dom-module id="at-core-dashboard">
  <template>
    <style include="at-form-common"></style>
    <style include="at-core-style-classes"></style>
    <style include="now-card-styles"></style>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }

      :host * {
        box-sizing: border-box;
      }

      .at-core-dashboard-wrapper {
        position: relative;
        height: 100%;
      }

      :host(:focus) {
        outline: none;
      }

      [class*='col-'] {
        padding-left: 0;
        padding-right: 0;
        float: left;
        min-height: inherit;
      }

      at-form-text {
        padding-left: 15px;
        padding-right: 15px;
        min-height: 76px;
      }

      #insertPoint {
        position: relative;
      }

      at-form-checkbox {
        min-height: 76px;
      }
      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 38px;
        visibility: hidden;
      }

      .vertical .col-6.at-form-checkbox {
        min-height: 32px;
        margin-bottom: 18px;
      }

      .vertical .col-6 at-form-checkbox {
        min-height: 32px;
      }
      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      .vertical .col-6 at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 16px;
        visibility: hidden;
      }
    </style>
    <div class="at-core-dashboard-wrapper">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clear-float"></div>
      <div id="insertPoint"></div>
    </div>
    <content></content>
  </template>
</dom-module>

<script>
  'use strict';
  Polymer({
    is: 'at-core-dashboard',
    behaviors: [ Tangere.behavior.handleLink, Tangere.behaviors.i18n ],
    hostAttributes: {
      tabindex: 0
    },
    properties: {
      /**
       * Specification of elements that should appear on the form.<br/>
       * Provide either an object or string.<br/>
       * List property definitions inside properties object.<br/>
       *
       * @property schema
       * @type Stirng or Object
       * @default { properties: {} }
       */
      schema: {
        type: Object,
        value: function () {
          var result = {
            properties: {}
          };
          return result;
        }
      },
      data: {
        type: Object,
        value: function () {
          return { _session: Tangere.session};
        },
        observer: 'dataChanged'
      },
      /**
       * When true hides all elements.
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged'
      },
      /**
       * When true disables all elements.
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      valid: {
        type: Boolean,
        notify: true,
        value: true,
        readOnly: true
      },
      namePrefix: {
        type: String,
        notify: true,
        value: ""
      },
      /**
       * at-core-dashboard can now have a one column or two column layout <br/>
       * by default a one column layout is used but a two column layout can be specified <br/>
       * layout = 'horizontal' renders the two column layout <br/>
       * layout = 'vertical' renders the single column layout <br/>
       *
       * @property layout
       * @type string
       * @default vertical
       */
      // added for #684
      layout: {
        type: String,
        value: "vertical",
        observer: 'layoutChanged',
        xtype: "enum",
        xvaluelist: "horizontal,vertical"
      },

      /**
      * at-core-form sectionMode governs the rendering of at-form-section <br/>
      * sectionMode === default, renders at-form-section as a heading
      * sectionMode === tab, renders at-form-section as a tab
      * all form-section elements form a tab group
      * iron-pages hold the elements belonging to a tab group
      * clicking a tab changes elements currently visible on screen
      *
      * @property sectionMode
      * @type string
      * @default default
      */
      sectionMode: {
        type: String,
        value: 'auto',
        xtype: "enum",
        xvaluelist: [{
          title: "Always Sections",
          value: "sections"
        }, {
          title: "Always Tabs",
          value: "tabs"
        }, {
          title: "Responsive",
          value: "auto"
        }, {
          title: "Tabs in mobile mode",
          value: "mobile"
        }]
      },

      /**
       * holds the value of the currently active tab when sectionMode === tab <br/>
       * has value of "" when sectionMode === default
       *
       * @property activeTab
       * @type string
       * @default ""
       */
      activeTab: {
        type: String,
        value: "",
        observer: '_activeTabChanged'
      }
    },

    get model() {
      return this.data.model;
    },

    set model(newValue) {
      this.data.model = newValue;
    },

    set valid(newValue) { },

    observers: [
      '_schemaChanged(schema)',
      '_sectionLayoutChanged(sectionMode, layout)'
    ],

    listeners: {
      'resolve-name-prefix': 'resolveNamePrefix'
    },

    resolveNamePrefix: function (e) {
      // allow nested elements (e.g. at-link) to retrieve the namePrefix of the "next" container
      e.detail.namePrefix = this.namePrefix;
      e.preventDefault();
    },

    ready: function () {
      this._isReady = true;
    },

    attached: function () {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
      resizeSensor.addEventListener('resize-sensed', function (event) {
        var newWidth = event.detail.value.width;
        // console.log('at-core-dashboard new width: ' + newWidth + 'px');
        coreForm.updateLayout(newWidth);
      });
    },

    updateLayout: function (newWidth, oldWidth) {
      if (isNaN(newWidth)) { return; }
      if (newWidth < 600) {
        this.layout = "vertical";
      } else {
        this.layout = "horizontal";
      }
    },

    /**
     * Focuses the element on the form with given elementId
     * If elementId is provided and element with provided elementId exists, its focused.
     * If elementId is not provided first element on the form is focused
     */
    setFocus: function (elementId) {
      var _sh = window.schemaHelpers;
      if (!_sh.isObject(this.schema) || !_sh.isObject(this.schema.properties)) {
        return;
      }

      var element;
      if (_sh.isString(elementId) && elementId !== "") {
        element = this.getElement(elementId);
      } else {
        // focus first element on the form
        var propertyNames = Object.getOwnPropertyNames(this.schema.properties);
        var firstElementName = propertyNames[0];
        element = this.getElement(firstElementName);
      }

      if (element !== null && _sh.isFunction(element.focus)) {
        element.focus();
      }
    },

    hideChanged: function (newValue, oldValue) {
      var self = this;
      var insertPoint = this.$.insertPoint;

      if (this.schema && this.schema.properties) {
        var properties = this.schema.properties;
        var propNames = Object.getOwnPropertyNames(properties);
        propNames.forEach(function (propName, index) {
          var formElement = Polymer.dom(insertPoint).querySelector('#' + propName);
          if (formElement && formElement.parentElement) {
            Polymer.dom(formElement.parentElement).classList.remove('hidden');
            formElement.hide = newValue;
          }
        });
      }
    },

    // when user switches to field settings tab, resize sensor is incorrectly initialized
    // so this function needs to be called to reinitialize the sensor
    resetResizeSensor: function () {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
    },

    _schemaChanged: function (newValue) {
      var schemaHelpers = window.schemaHelpers;
      var self = this;

      // debugger;

      if (schemaHelpers.isString(newValue)) {
        /*
        if newValue for schema is given as json string, parse it and assign it to this.schema
        if newValue is a valid json string this.schema will trigger __schemaChanged again so we return to prevent schema changes being applied twice
        if newValue is an invalid json string just return. Whatever the previous schema was that remains visible to the user
        */
        try {
          newValue = JSON.parse(newValue);
          this.schema = newValue;
        } catch (e) {
          console.log(e);
        }
        return;
      }

      if (!schemaHelpers.isObject(newValue) || !schemaHelpers.isObject(newValue.properties)) {
        return;
      }

      // figure out the list of the elements that should be imported
      schemaHelpers.initializeCentralArrayOfComponents();
      var _properties = newValue.properties;
      var _propertyNames = Object.getOwnPropertyNames(newValue.properties);
      var nonImportedElements = [];

      var nonGroupedElements;
      var formGroups = [];
      var currentGroupName = "";
      var currentGroupElements = nonGroupedElements = [];

      _propertyNames.forEach(function (propName, index) {
        var propDef = _properties[propName];
        var displayType = schemaHelpers.getDisplayType(propDef, []);
        var mapping = schemaHelpers.findMapping(displayType);

        if (!mapping) {
          // element is not loaded; scheadule it for importHref
          propDef.displayType = displayType;
          nonImportedElements.push(propDef);
        }

        if (displayType !== 'section') {
          currentGroupElements.push({ name: propName, definition: propDef });
        } else {
          // open a new group
          currentGroupName = propName;
          currentGroupElements = [{ name: propName, definition: propDef }];
          formGroups.push({
            name: currentGroupName,
            label: propDef.title || currentGroupName,
            elements:  currentGroupElements
          });
        }
      });

      var displayTypeToFormElementMapping = {
        date: "at-form-date",
        time: "at-form-date",
        datetime: "at-form-date",
        daterange: "at-form-daterange",
        string: "at-form-text",
        section: "at-form-section"
      };

      if (nonImportedElements.length) {
        var pendingImportsCount = nonImportedElements.length;

        nonImportedElements.forEach(function (propDef, index) {
          // To construct elemHref we need static information about what (type, xtype) maps to which at-form element
          // Right now, only $meta in each element contains this information and central array of components is populated with $meta information
          // So, to dynamically importHref needed elements we need to introduce static information (which will just be a copy paste from $meta of each element)

          var displayType = propDef.displayType;
          var elementName = displayTypeToFormElementMapping[displayType];
          elementName = !elementName ? displayType : elementName;

          // construct elemHref
          var compUrl = document.baseURI.indexOf("/components/") >= 0 ? "/components/" : "components/";

          if (document.URL.indexOf("/elements/designer-element/") >= 0) {
            compUrl = "/components/";
          }

          if (window.ComponentsBase != undefined) {
            compUrl = window.ComponentsBase;
          }
          var elemHref = compUrl + elementName + "/" + elementName + ".html";

          self.importHref(elemHref, function(e) {
            // import was successful
            pendingImportsCount -= 1;
            if (!pendingImportsCount) {
              self._renderSchema(nonGroupedElements, formGroups);
            }
          }, function (e) {
            // import failed
            console.log("import failed: " + e.target.href);
          }, true);
        });
      } else {
        this._renderSchema(nonGroupedElements, formGroups);
      }
    },

    _renderSchema: function (nonGroupedElements, formGroups) {

      var self = this;
      var schemaHelpers = window.schemaHelpers;
      var divPrototype = document.createElement('div');

      self.elementsToValidate = [];

      var fieldsContainer = this.$.insertPoint;
      // clear the previous html content in the container
      Polymer.dom(fieldsContainer).innerHTML = '';

      // initialize data with defaults when empty
      if (!self.data || Object.getOwnPropertyNames(self.data).length === 0) {
        self.data = this._calculateInitialDataFromSchemaProperties(self.schema.properties);
      }

      // add schema elements to DOM
      nonGroupedElements.forEach(function (element) {
        var propertyName = element.name;
        var propertyDefinition = element.definition;
        self._renderSingleElement(propertyName, propertyDefinition, divPrototype, fieldsContainer);
      });

      if (formGroups.length) {
        var sectionMode = self.sectionMode;
        var layout = self.layout;
        self._hideTabs = sectionMode ==="sections" ||
          (sectionMode === "auto" && layout === "horizontal") ||
          (sectionMode === "mobile" && layout === "horizontal");

        self._hideHeadings = ["mobile", "tabs"].indexOf(sectionMode) !== -1 ||
          (sectionMode === "auto" && layout === "vertical");
        var selectedSection = self.activeTab || formGroups[0].name;

        // create tab group
        var col12 = divPrototype.cloneNode(true);
        Polymer.dom(col12).classList.add('col-12');
        var carbonTabs = document.createElement('at-carbon-tabs');
        Polymer.dom(fieldsContainer).appendChild(col12);
        Polymer.dom(col12).appendChild(carbonTabs);
        carbonTabs.hidden = self._hideTabs;

        formGroups.forEach(function(group, index) {
          var name = group.name;
          var label = group.label;
          var carbonTab = document.createElement('at-carbon-tab');
          Polymer.dom(carbonTab).setAttribute('id', name);
          Polymer.dom(carbonTab).innerHTML = label;
          Polymer.dom(carbonTabs).appendChild(carbonTab);

          var ironPage = divPrototype.cloneNode(true);
          Polymer.dom(fieldsContainer).appendChild(ironPage);
          Polymer.dom(ironPage).setAttribute('at-core-form-section-id', name);
          self.toggleClass('hidden', !self._hideTabs && name !== selectedSection, ironPage);

          var elements = group.elements;
          elements.forEach(function (element, index) {
            var propertyName = element.name;
            var propertyDefinition = JSON.parse(JSON.stringify(element.definition));
            if (!index) {
              propertyDefinition.hide = self._hideHeadings;
            }

            self._renderSingleElement(propertyName, propertyDefinition, divPrototype, ironPage);
          });
        });

        carbonTabs.$.tabsContent.attrForSelected = 'id';
        carbonTabs.selected = selectedSection;

        carbonTabs.addEventListener('selected-changed', function(event) {
          if (self._hideTabs) { return; }
          self.activeTab = event.detail.value;
          var sections = Polymer.dom(self.$.insertPoint).querySelectorAll('div[at-core-form-section-id]');
          sections.forEach(function(section, index) {
            var sectionId = section.getAttribute('at-core-form-section-id');
            self.toggleClass('hidden', sectionId !== self.activeTab, section);
          });
        });
      }

      var propertyNames = Object.getOwnPropertyNames(self.schema.properties);
      var propertyDefinitions = self.schema.properties;

      // initialize default values after elements are added to the DOM to ensure that listeners are already in place
      propertyNames.forEach(function (propertyName) {

        var propertyDefinition = propertyDefinitions[propertyName];
        var formElement = self.getElement(propertyName);

        if (!formElement) return;

        // handle default value
        var defaultValue = propertyDefinition.default;


        // register .value variable in router and get value if exsting in state
        if (!!formElement.$meta && !(formElement.$meta[0].invisible === true) && formElement.$meta[0].stateProperties === undefined) {
          var ev = { name: propertyName, defaultValue: defaultValue, element: formElement };
          Polymer.signal("register-state-var", ev);
          if (ev.value !== undefined) defaultValue = ev.value;
        }

        // setup changed listeners for stateProperties
        if (!!formElement.$meta && formElement.$meta[0].stateProperties !== undefined) {
          for (var i = 0; i < formElement.$meta[0].stateProperties.length; i++) {
            var propName = formElement.$meta[0].stateProperties[i];
            var elName = formElement.id;
            var ev = { name: elName + "." + propName, defaultValue: formElement[propName], element: formElement };
            Polymer.signal("register-state-var", ev);
            if (ev.value !== undefined) formElement[propName] = ev.value;
          }
        }

        // if default value is not null or undefined and regular value is null or undefined
        // loading initial value will trigger value-changed event to update .data if defaultValue is valid
        if (schemaHelpers.notNullOrEmpty(defaultValue) && schemaHelpers.isNullOrEmpty(value)) {
          formElement.value = defaultValue;

          // *ma* setting the defautValue should be after setting up the event listener and only the listener should handle
          //      the value change; but it seems that setting the initial value doesn't trigger a change event consistently
          //      so as a workaround we call the event handler directly before setting up the listener

          self._updateDataObject(propertyName, formElement, defaultValue);
        }

      });

      // add div class="clearfix"
      var clearfixDiv = document.createElement('div');
      Polymer.dom(clearfixDiv).classList.add('clear-float');
      Polymer.dom(fieldsContainer).appendChild(clearfixDiv);

      self.fire('rendered', this, { bubbles: false });

      var resizeSensor = this.$.resizeSensor;
      resizeSensor.reset();
      var width = resizeSensor.queryWidth();
      this.updateLayout(width);

      this.addEventListener('keypress', function (event) {

        // validate() will trigger change event(s) if needed
        if (event.keyCode == 13) {
          this.validate();
        }

      });

      this.setFocus();

      // send _start event
      var event = this._createEventObject("_start", null, null, null, this.data);
      this._invokeActionListeners(event);

    },

    _renderSingleElement: function (propertyName, propertyDefinition, divPrototype, fieldsFragment) {
      var self = this;
      var defaultValue;
      var value;
      var xgridcols;
      var gridColsCssName;
      var fieldContainer;
      var formElement;
      var displayType;

      if (schemaHelpers.isPropertyNameValid(propertyName)) {
        displayType = schemaHelpers.getDisplayType(propertyDefinition, []);

        // handle xgridcols
        xgridcols = displayType === "section" ? 12 : 6;
        if (schemaHelpers.notNullOrEmpty(propertyDefinition.xgridcols)) {
          xgridcols = parseInt(propertyDefinition.xgridcols);
        }
        xgridcols = displayType === "section" ? 12 : xgridcols;

        // create element for field
        formElement = schemaHelpers.createElement(propertyName, displayType, propertyDefinition);
        Polymer.dom(formElement).setAttribute('id', propertyName);

        // create the field container
        fieldContainer = document.createElement('div');
        gridColsCssName = "col-" + xgridcols;
        Polymer.dom(fieldContainer).classList.add(gridColsCssName);

        // special container for at-form-toggle to allow smaller height in vertical mode
        if (formElement.tagName.toLowerCase() == "at-form-checkbox") {
          Polymer.dom(fieldContainer).classList.add("at-form-checkbox");
        }

        if (formElement.clearUIValidState !== undefined) {
          // at-form-section doesn't have clearUIValidState function nor does it need one
          formElement.clearUIValidState();
        }

        // setup changed listener for .value property to update data and call listeners
        if (formElement.properties["value"] != undefined) {
          formElement.addEventListener('value-changed', function (event) {
            // get dom node of changed element
            var changedElement = self.getElement(event.target.id);
            self._updateDataObject(event.target.id, changedElement, event.detail.value);
          });
        }

        // setup changed listeners for stateProperties
        if (!!formElement.$meta && formElement.$meta[0].stateProperties !== undefined) {
          for (var i = 0; i < formElement.$meta[0].stateProperties.length; i++) {
            var statePropertyName = formElement.$meta[0].stateProperties[i];

            if (statePropertyName !== "value") {  // value is already handled in _updateDataObject

              formElement.addEventListener(Polymer.CaseMap.camelToDashCase(statePropertyName) + '-changed', function (event) {
                var elName = event.target.id;
                var propName = event.type.replace("-changed", "");
                propName = Polymer.CaseMap.dashToCamelCase(propName);
                var ev = { name: elName + "." + propName, value: event.detail.value };
                Polymer.signal("update-state-var", ev);
              });

            }
          }
        }

        if (formElement.valid !== undefined) {
          self.elementsToValidate.push(formElement);
        }

        // if at-core-dashboard is hidden, element should be hidden as well
        if (self.hide) {
          formElement.hide = true;
        }

        // append paper element to its container
        Polymer.dom(fieldContainer).appendChild(formElement);

        if (formElement.hide) {
          Polymer.dom(fieldContainer).classList.add('hidden');
        }

        // add container to as child to insertPoint
        Polymer.dom(fieldsFragment).appendChild(fieldContainer);

        // udpate the disabled status
        self.disabledChanged(self.disabled, self.disabled);
      } else {
        console.log('Property name is invalid. Skipping ' + propertyName + ' property');
        console.log('Property definition is:  ', schemaHelpers.formatJson(propertyDefinition));
      }
    },

    _sectionLayoutChanged: function (sectionMode, layout) {
      var carbonTabs = Polymer.dom(this.$.insertPoint).querySelector('at-carbon-tabs');
      var sections = Polymer.dom(this.$.insertPoint).querySelectorAll('div[at-core-form-section-id]');
      var headings = Polymer.dom(this.$.insertPoint).querySelectorAll('at-form-section');
      var self = this;
      var sectionMode = self.sectionMode;
      var layout = self.layout;
      var hideTabs = self._hideTabs = sectionMode ==="sections" ||
        (sectionMode === "auto" && layout === "horizontal") ||
        (sectionMode === "mobile" && layout === "horizontal");
      var hideHeadings = self._hideHeadings = ["mobile", "tabs"].indexOf(sectionMode) !== -1 ||
        (sectionMode === "auto" && layout === "vertical");

      var selectedSection = this.activeTab;
      if (carbonTabs) { carbonTabs.hidden = hideTabs; }
      sections.forEach(function(section, index) {
        var sectionId = section.getAttribute('at-core-form-section-id');
        self.toggleClass('hidden', !hideTabs && sectionId !== selectedSection, section);
      });

      headings.forEach(function(heading, index){
        heading.hide = hideHeadings;
        self.toggleClass('hidden', hideHeadings, heading.parentElement);
      });

    },

    _activeTabChanged: function (newValue, oldValue) {
      // this is here to prevent rerendering of at-core-form when activeTab
      // is updated by clicking an at-carbon-tab on at-carbon-tabs

      var carbonTabs = Polymer.dom(this.root).querySelector('at-carbon-tabs');
      if (carbonTabs && carbonTabs.selected !== newValue) {
        carbonTabs.selected = newValue;
      }
    },

    /* *ij*
     Imperative data binding doesn't work in polymer 1.x.
     Using at-core-dashboard.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-dashboard.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementData function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console
     */
    updateFormElementData: function (elementId, value) {
      var fieldsContainer = this.$.insertPoint,
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + elementId);

      this.data[elementId] = value;
      if (schemaHelpers.valueNotReadOnly(fieldElement)) {
        fieldElement.value = value;
        // *ij* polymer js doesn't call valueChanged if value is of type array or object
        // we check for this situation and call valueChanged by hand
        if (schemaHelpers.isObject(fieldElement.value) || schemaHelpers.isArray(fieldElement.value)) {
          fieldElement.valueChanged(value, undefined);
        }
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    setElementState: function (elementId, state, value) {

      var element = Polymer.dom(this.$.insertPoint).querySelector('#' + elementId);
      if (element) {
        element[state] = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    getElement: function (elementId) {

      var insertPoint = this.$.insertPoint;
      var selector = '#' + elementId;
      var element = Polymer.dom(insertPoint).querySelector(selector);

      return element;
    },

    dataChanged: function (newValue, oldValue) {

      if (!this._isReady) {
        return;
      }

      return; // *ma*   can data be changed without changing an element first ??

      var fieldsContainer = Polymer.dom(this.$.insertPoint);
      var fieldElement;
      var properties = this.schema.properties;
      var initialData = this._calculateInitialDataFromSchemaProperties(properties);

      if (schemaHelpers.isString(newValue)) {
        try {
          newValue = JSON.parse(newValue);
          this.data = newValue;
          return;
        } catch (e) {
          console.log(e);
        }
      }

      if (schemaHelpers.isObject(oldValue)) {
        Object.getOwnPropertyNames(initialData).forEach(function (propertyName) {
          if (!newValue.hasOwnProperty(propertyName)) {
            newValue[propertyName] = initialData[propertyName];
          }
        });
      }

      var self = this;
      if (schemaHelpers.isObject(newValue)) {
        Object.getOwnPropertyNames(newValue).forEach(function (propertyName) {
          fieldElement = self.getElement(propertyName);
          if (schemaHelpers.valueNotReadOnly(fieldElement)) {
            fieldElement.value = newValue[propertyName];
          }
        });
      } else {
        console.log('at-core-dashboard expects objects as new value, but got ' + schemaHelpers.formatJson(newValue) + ' instead');
      }

      this.fire('data-changed', {
        value: this.data
      });
    },

    // invoke listeners on all elements listening for event
    _invokeActionListeners: function (event) {

      var properties = this.schema.properties;
      var propertyNames = Object.getOwnPropertyNames(properties);

      // check each element in the schema if it's listing for event.name
      for (var i = 0; i < propertyNames.length; i++) {
        var propName = propertyNames[i];
        var propDef = properties[propName];
        var element = this.getElement(propName); // element on which actionListener function will be called

        var actionListeners;

        if (propName == event.detail.srcName) {
          continue; // skip, element cannot listen to self
        }

        // ensure that actionListeners is an array
        if (typeof (propDef.actionListeners) == "string") {
          if (!propDef.actionListeners) {
            actionListeners = [propDef.actionListeners]; // convert single string to string array
          } else {
            actionListeners = []; // convert empty string into empty array
          }
        } else {
          actionListeners = propDef.actionListeners;
        }

        // ignore properties without listeners
        if (!propDef.actionListeners || actionListeners.length == 0) continue;

        for (var j = 0; j < actionListeners.length; j++) {

          var listenerName = actionListeners[j];

          if (typeof listenerName == "object" && !!listenerName.value) {
            // convert object { value: name} to "name"
            listenerName = listenerName.value;
          }

          // skip if element is not listening for current event
          // *todo* decide if eventtype for element name is  'name' (designer)   or  'name-changed'  (which seems more logical)
          if (listenerName != "_all" && listenerName != event.type && listenerName + "-changed" != event.type) {
            continue;
          }

          if (isFunction(element.actionListener)) {
            element.actionListener(event);
          }

        }
      }
    },

    /*
     * This function is called on value-changed event for any element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateDataObject: function (property, changedElement, value) {

      // if an element has an .valid flag then the change is ignored when element value is not valid
      if (changedElement.valid !== undefined && !changedElement.valid) {
        return; // ignore change
      }

      this.data[property] = value;

      var event = this._createEventObject(property + "-changed", property, changedElement, value, this.data);

      this._invokeActionListeners(event);

      this.fire('data-changed', {
        property: property,
        value: this.data
      });

      if (!!changedElement.$meta && !(changedElement.$meta[0].invisible === true)) {
        var ev = { name: property, value: value };
        Polymer.signal("update-state-var", ev);
      }

    },

    _createEventObject: function (type, srcName, srcElement, value, data) {
      return {
        type: type,
        detail: {
          srcName: srcName,
          parameter: value,
          model: {
            state: data
          }
        }
      }
    },

    /* data is always valid
    _calculateFormValidState: function () {
      var isValid = true;

      this.elementsToValidate.forEach(function (element) {
        // there are elements that do not have valid property (like at-silver-transform or at-silver-datasource)
        // these elements are valid by default
        var elementValid = element.valid !== undefined ? element.valid : true;
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },
    */

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function () {
      var isValid = true;

      this.elementsToValidate.forEach(function (element) {
        var elementValid = element.validate();
        isValid = isValid && elementValid;
      });

      this._setValid(isValid);

      return isValid;
    },

    disabledChanged: function (newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint;
      var fieldElement;
      var properties = this.schema.properties;

      Object.getOwnPropertyNames(properties).forEach(function (propertyName) {
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
          if (newValue) {
            fieldElement.disabled = newValue;
          } else {
            fieldElement.disabled = Boolean(properties[propertyName].disabled);
          }
        }
      });
    },

    layoutChanged: function (newValue, oldValue) {
      this.toggleClass('vertical', newValue === 'vertical', this.$.insertPoint);
    },

    _convertPropertiesToSchemaValues: function (properties) {
      var result = {
        schema: {
          properties: {}
        },
        values: {}
      },
        property,
        propDef,
        innerProp,
        propObj;

      for (property in properties) {
        propObj = result.properties[property] = {};
        propDef = properties[property];
        for (innerProp in propDef) {
          if (innerProp === 'value') {
            result.values[property] = propDef[innerProp];
          } else {
            propObj[innerProp] = propDef[innerProp];
          }
        }
      }

      return result;
    },

    /**
     * this function creates initial data object from schema properties
     */
    _calculateInitialDataFromSchemaProperties: function (properties) {

      var result = {};
      var propertyNames = Object.getOwnPropertyNames(properties);
      var propSchemaDef;
      var calculatedValue;

      propertyNames.forEach(function (propName, index) {
        propSchemaDef = properties[propName];

        // if .default exists in propSchemaDef that is the calculatedValue
        if (propSchemaDef.default !== undefined) {
          calculatedValue = propSchemaDef.default;
          result[propName] = calculatedValue;
        }
      });

      return result;
    }

  });

  function isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  }

  function isFunction(obj) {
    return Object.prototype.toString.apply(obj) === "[object Function]";
  }
</script>
